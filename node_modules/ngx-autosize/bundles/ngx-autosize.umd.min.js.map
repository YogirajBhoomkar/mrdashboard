{"version":3,"sources":["ng://ngx-autosize/lib/window-ref.service.ts","ng://ngx-autosize/lib/autosize.directive.ts","ng://ngx-autosize/lib/autosize.module.ts"],"names":["WindowRef","Object","defineProperty","prototype","window","Injectable","AutosizeDirective","element","_window","_zone","this","onlyGrow","useImportant","resized","EventEmitter","autosize","retries","_destroyed","nativeElement","tagName","_findNestedTextArea","textAreaEl","style","_onTextAreaFound","value","_minRows","rows","onInput","textArea","adjust","ngOnDestroy","_windowResizeHandler","nativeWindow","removeEventListener","ngAfterContentChecked","ngOnChanges","changes","_this","querySelector","shadowRoot","console","warn","setTimeout","_addWindowResizeHandler","func","wait","immediate","timeout","context","args","arguments","later","apply","callNow","clearTimeout","Debounce","run","runOutsideAngular","addEventListener","inputsChanged","parentNode","currentText","_oldContent","offsetWidth","_oldWidth","clone","cloneNode","parent_1","width","visibility","position","textContent","appendChild","height","scrollHeight","computedStyle","getComputedStyle","parseInt","getPropertyValue","oldHeight","offsetHeight","willGrow","lineHeight","_getLineHeight","rowsCount","maxRows","maxHeight","Math","max","heightStyle","important","setProperty","emit","removeChild","isNaN","styles","fontSize","floor","replace","Directive","selector","ElementRef","NgZone","Input","Output","HostListener","AutosizeModule","NgModule","declarations","imports","providers","exports"],"mappings":"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","sourcesContent":["import { Injectable } from '@angular/core';\n\n@Injectable()\nexport class WindowRef {\n  get nativeWindow(): any {\n    return window;\n  }\n}\n","import {\n    ElementRef,\n    HostListener,\n    Directive,\n    Input,\n    NgZone, OnDestroy, OnChanges, AfterContentChecked, Output, EventEmitter\n} from '@angular/core';\nimport {WindowRef} from './window-ref.service';\n\nconst MAX_LOOKUP_RETRIES = 3;\n\n@Directive({\n    selector: '[autosize]'\n})\n\nexport class AutosizeDirective implements OnDestroy, OnChanges, AfterContentChecked {\n    @Input()\n    set minRows(value) {\n        this._minRows = value;\n        if (this.textAreaEl) {\n            this.textAreaEl.rows = value;\n        }\n    };\n    @Input('autosize')\n    set _autosize(autosize: boolean | string) {\n        this.autosize = typeof autosize === 'boolean'\n            ? autosize\n            : true;\n    };\n    private _minRows: number;\n\n    @Input() maxRows: number;\n    @Input() onlyGrow = false;\n    @Input() useImportant = false;\n\n    @Output() resized = new EventEmitter<number>();\n\n    private autosize = true;\n    private retries = 0;\n    private textAreaEl: any;\n\n    private _oldContent: string;\n    private _oldWidth: number;\n\n    private _windowResizeHandler;\n    private _destroyed = false;\n\n    @HostListener('input', ['$event.target'])\n    onInput(textArea: HTMLTextAreaElement): void {\n        this.adjust();\n    }\n\n    constructor(\n        public element: ElementRef,\n        private _window: WindowRef,\n        private _zone: NgZone\n    ) {\n        if (this.element.nativeElement.tagName !== 'TEXTAREA') {\n            this._findNestedTextArea();\n\n        } else {\n            this.textAreaEl = this.element.nativeElement;\n            this.textAreaEl.style['overflow-y'] = 'hidden';\n            this._onTextAreaFound();\n        }\n    }\n\n    ngOnDestroy() {\n        this._destroyed = true;\n        if (this._windowResizeHandler) {\n            this._window.nativeWindow.removeEventListener('resize', this._windowResizeHandler, false);\n        }\n    }\n\n    ngAfterContentChecked() {\n        this.adjust();\n    }\n\n    ngOnChanges(changes) {\n        this.adjust(true);\n    }\n\n    _findNestedTextArea() {\n        this.textAreaEl = this.element.nativeElement.querySelector('TEXTAREA');\n\n        if (!this.textAreaEl && this.element.nativeElement.shadowRoot) {\n            this.textAreaEl = this.element.nativeElement.shadowRoot.querySelector('TEXTAREA');\n        }\n\n        if (!this.textAreaEl) {\n            if (this.retries >= MAX_LOOKUP_RETRIES) {\n                console.warn('ngx-autosize: textarea not found');\n\n            } else {\n                this.retries++;\n                setTimeout(() => {\n                    this._findNestedTextArea();\n                }, 100);\n            }\n            return;\n        }\n\n        this.textAreaEl.style['overflow-y'] = 'hidden';\n        this._onTextAreaFound();\n\n    }\n\n    _onTextAreaFound() {\n        this._addWindowResizeHandler();\n        setTimeout(() => {\n            this.adjust();\n        });\n    }\n\n    _addWindowResizeHandler() {\n        this._windowResizeHandler = Debounce(() => {\n            this._zone.run(() => {\n                this.adjust();\n            });\n        }, 200);\n\n        this._zone.runOutsideAngular(() => {\n            this._window.nativeWindow.addEventListener('resize', this._windowResizeHandler, false);\n        });\n    }\n\n    adjust(inputsChanged = false): void {\n        if (this.autosize && !this._destroyed && this.textAreaEl && this.textAreaEl.parentNode) {\n\n            const currentText = this.textAreaEl.value;\n\n            if (\n                inputsChanged === false &&\n                currentText === this._oldContent &&\n                this.textAreaEl.offsetWidth === this._oldWidth\n            ) {\n                return;\n            }\n\n            this._oldContent = currentText;\n            this._oldWidth = this.textAreaEl.offsetWidth;\n\n            const clone = this.textAreaEl.cloneNode(true);\n            const parent = this.textAreaEl.parentNode;\n            clone.style.width = this.textAreaEl.offsetWidth + 'px';\n            clone.style.visibility = 'hidden';\n            clone.style.position = 'absolute';\n            clone.textContent = currentText;\n\n            parent.appendChild(clone);\n\n            clone.style['overflow-y'] = 'hidden';\n            clone.style.height = 'auto';\n\n            let height = clone.scrollHeight;\n\n            // add into height top and bottom borders' width\n            let computedStyle = this._window.nativeWindow.getComputedStyle(clone, null);\n            height += parseInt(computedStyle.getPropertyValue('border-top-width'));\n            height += parseInt(computedStyle.getPropertyValue('border-bottom-width'));\n\n            // add into height top and bottom paddings width\n            height += parseInt(computedStyle.getPropertyValue('padding-top'));\n            height += parseInt(computedStyle.getPropertyValue('padding-bottom'));\n\n\n            const oldHeight = this.textAreaEl.offsetHeight;\n            const willGrow = height > oldHeight;\n\n            if (this.onlyGrow === false || willGrow) {\n                const lineHeight = this._getLineHeight();\n                const rowsCount = height / lineHeight;\n\n                if (this._minRows && this._minRows >= rowsCount) {\n                    height = this._minRows * lineHeight;\n\n                } else if (this.maxRows && this.maxRows <= rowsCount) {\n                    // never shrink the textarea if onlyGrow is true\n                    const maxHeight = this.maxRows * lineHeight;\n                    height = this.onlyGrow ? Math.max(maxHeight, oldHeight): maxHeight;\n                    this.textAreaEl.style['overflow-y'] = 'auto';\n\n                } else {\n                    this.textAreaEl.style['overflow-y'] = 'hidden';\n                }\n\n                const heightStyle = height + 'px';\n                const important = this.useImportant ? 'important' : '';\n\n                this.textAreaEl.style.setProperty('height', heightStyle, important);\n\n                this.resized.emit(height);\n            }\n\n            parent.removeChild(clone);\n        }\n    }\n\n    private _getLineHeight() {\n        let lineHeight = parseInt(this.textAreaEl.style.lineHeight, 10);\n        if (isNaN(lineHeight) && this._window.nativeWindow.getComputedStyle) {\n            const styles = this._window.nativeWindow.getComputedStyle(this.textAreaEl);\n            lineHeight = parseInt(styles.lineHeight, 10);\n        }\n\n        if (isNaN(lineHeight)) {\n            const fontSize = this._window.nativeWindow.getComputedStyle(this.textAreaEl, null).getPropertyValue('font-size');\n            lineHeight = Math.floor(parseInt(fontSize.replace('px', ''), 10) * 1.5);\n        }\n\n        return lineHeight;\n    }\n}\n\nfunction Debounce(func, wait, immediate = false) {\n    let timeout;\n    return function () {\n        const context = this;\n        const args = arguments;\n        const later = function () {\n            timeout = null;\n            if (!immediate) {\n                func.apply(context, args);\n            }\n        };\n        const callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) {\n            func.apply(context, args);\n        }\n    };\n}\n","import {NgModule} from '@angular/core';\nimport {AutosizeDirective} from './autosize.directive';\nimport {WindowRef} from './window-ref.service';\n\n@NgModule({\n    declarations: [AutosizeDirective],\n    imports: [],\n    providers: [\n        WindowRef\n    ],\n    exports: [AutosizeDirective]\n})\nexport class AutosizeModule {\n}\n"]}