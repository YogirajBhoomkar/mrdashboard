/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ElementRef, HostListener, Directive, Input, NgZone, Output, EventEmitter } from '@angular/core';
import { WindowRef } from './window-ref.service';
/** @type {?} */
const MAX_LOOKUP_RETRIES = 3;
export class AutosizeDirective {
    /**
     * @param {?} element
     * @param {?} _window
     * @param {?} _zone
     */
    constructor(element, _window, _zone) {
        this.element = element;
        this._window = _window;
        this._zone = _zone;
        this.onlyGrow = false;
        this.useImportant = false;
        this.resized = new EventEmitter();
        this.autosize = true;
        this.retries = 0;
        this._destroyed = false;
        if (this.element.nativeElement.tagName !== 'TEXTAREA') {
            this._findNestedTextArea();
        }
        else {
            this.textAreaEl = this.element.nativeElement;
            this.textAreaEl.style['overflow-y'] = 'hidden';
            this._onTextAreaFound();
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set minRows(value) {
        this._minRows = value;
        if (this.textAreaEl) {
            this.textAreaEl.rows = value;
        }
    }
    ;
    /**
     * @param {?} autosize
     * @return {?}
     */
    set _autosize(autosize) {
        this.autosize = typeof autosize === 'boolean'
            ? autosize
            : true;
    }
    ;
    /**
     * @param {?} textArea
     * @return {?}
     */
    onInput(textArea) {
        this.adjust();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._destroyed = true;
        if (this._windowResizeHandler) {
            this._window.nativeWindow.removeEventListener('resize', this._windowResizeHandler, false);
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentChecked() {
        this.adjust();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.adjust(true);
    }
    /**
     * @return {?}
     */
    _findNestedTextArea() {
        this.textAreaEl = this.element.nativeElement.querySelector('TEXTAREA');
        if (!this.textAreaEl && this.element.nativeElement.shadowRoot) {
            this.textAreaEl = this.element.nativeElement.shadowRoot.querySelector('TEXTAREA');
        }
        if (!this.textAreaEl) {
            if (this.retries >= MAX_LOOKUP_RETRIES) {
                console.warn('ngx-autosize: textarea not found');
            }
            else {
                this.retries++;
                setTimeout((/**
                 * @return {?}
                 */
                () => {
                    this._findNestedTextArea();
                }), 100);
            }
            return;
        }
        this.textAreaEl.style['overflow-y'] = 'hidden';
        this._onTextAreaFound();
    }
    /**
     * @return {?}
     */
    _onTextAreaFound() {
        this._addWindowResizeHandler();
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.adjust();
        }));
    }
    /**
     * @return {?}
     */
    _addWindowResizeHandler() {
        this._windowResizeHandler = Debounce((/**
         * @return {?}
         */
        () => {
            this._zone.run((/**
             * @return {?}
             */
            () => {
                this.adjust();
            }));
        }), 200);
        this._zone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            this._window.nativeWindow.addEventListener('resize', this._windowResizeHandler, false);
        }));
    }
    /**
     * @param {?=} inputsChanged
     * @return {?}
     */
    adjust(inputsChanged = false) {
        if (this.autosize && !this._destroyed && this.textAreaEl && this.textAreaEl.parentNode) {
            /** @type {?} */
            const currentText = this.textAreaEl.value;
            if (inputsChanged === false &&
                currentText === this._oldContent &&
                this.textAreaEl.offsetWidth === this._oldWidth) {
                return;
            }
            this._oldContent = currentText;
            this._oldWidth = this.textAreaEl.offsetWidth;
            /** @type {?} */
            const clone = this.textAreaEl.cloneNode(true);
            /** @type {?} */
            const parent = this.textAreaEl.parentNode;
            clone.style.width = this.textAreaEl.offsetWidth + 'px';
            clone.style.visibility = 'hidden';
            clone.style.position = 'absolute';
            clone.textContent = currentText;
            parent.appendChild(clone);
            clone.style['overflow-y'] = 'hidden';
            clone.style.height = 'auto';
            /** @type {?} */
            let height = clone.scrollHeight;
            // add into height top and bottom borders' width
            /** @type {?} */
            let computedStyle = this._window.nativeWindow.getComputedStyle(clone, null);
            height += parseInt(computedStyle.getPropertyValue('border-top-width'));
            height += parseInt(computedStyle.getPropertyValue('border-bottom-width'));
            // add into height top and bottom paddings width
            height += parseInt(computedStyle.getPropertyValue('padding-top'));
            height += parseInt(computedStyle.getPropertyValue('padding-bottom'));
            /** @type {?} */
            const oldHeight = this.textAreaEl.offsetHeight;
            /** @type {?} */
            const willGrow = height > oldHeight;
            if (this.onlyGrow === false || willGrow) {
                /** @type {?} */
                const lineHeight = this._getLineHeight();
                /** @type {?} */
                const rowsCount = height / lineHeight;
                if (this._minRows && this._minRows >= rowsCount) {
                    height = this._minRows * lineHeight;
                }
                else if (this.maxRows && this.maxRows <= rowsCount) {
                    // never shrink the textarea if onlyGrow is true
                    /** @type {?} */
                    const maxHeight = this.maxRows * lineHeight;
                    height = this.onlyGrow ? Math.max(maxHeight, oldHeight) : maxHeight;
                    this.textAreaEl.style['overflow-y'] = 'auto';
                }
                else {
                    this.textAreaEl.style['overflow-y'] = 'hidden';
                }
                /** @type {?} */
                const heightStyle = height + 'px';
                /** @type {?} */
                const important = this.useImportant ? 'important' : '';
                this.textAreaEl.style.setProperty('height', heightStyle, important);
                this.resized.emit(height);
            }
            parent.removeChild(clone);
        }
    }
    /**
     * @private
     * @return {?}
     */
    _getLineHeight() {
        /** @type {?} */
        let lineHeight = parseInt(this.textAreaEl.style.lineHeight, 10);
        if (isNaN(lineHeight) && this._window.nativeWindow.getComputedStyle) {
            /** @type {?} */
            const styles = this._window.nativeWindow.getComputedStyle(this.textAreaEl);
            lineHeight = parseInt(styles.lineHeight, 10);
        }
        if (isNaN(lineHeight)) {
            /** @type {?} */
            const fontSize = this._window.nativeWindow.getComputedStyle(this.textAreaEl, null).getPropertyValue('font-size');
            lineHeight = Math.floor(parseInt(fontSize.replace('px', ''), 10) * 1.5);
        }
        return lineHeight;
    }
}
AutosizeDirective.decorators = [
    { type: Directive, args: [{
                selector: '[autosize]'
            },] }
];
/** @nocollapse */
AutosizeDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: WindowRef },
    { type: NgZone }
];
AutosizeDirective.propDecorators = {
    minRows: [{ type: Input }],
    _autosize: [{ type: Input, args: ['autosize',] }],
    maxRows: [{ type: Input }],
    onlyGrow: [{ type: Input }],
    useImportant: [{ type: Input }],
    resized: [{ type: Output }],
    onInput: [{ type: HostListener, args: ['input', ['$event.target'],] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    AutosizeDirective.prototype._minRows;
    /** @type {?} */
    AutosizeDirective.prototype.maxRows;
    /** @type {?} */
    AutosizeDirective.prototype.onlyGrow;
    /** @type {?} */
    AutosizeDirective.prototype.useImportant;
    /** @type {?} */
    AutosizeDirective.prototype.resized;
    /**
     * @type {?}
     * @private
     */
    AutosizeDirective.prototype.autosize;
    /**
     * @type {?}
     * @private
     */
    AutosizeDirective.prototype.retries;
    /**
     * @type {?}
     * @private
     */
    AutosizeDirective.prototype.textAreaEl;
    /**
     * @type {?}
     * @private
     */
    AutosizeDirective.prototype._oldContent;
    /**
     * @type {?}
     * @private
     */
    AutosizeDirective.prototype._oldWidth;
    /**
     * @type {?}
     * @private
     */
    AutosizeDirective.prototype._windowResizeHandler;
    /**
     * @type {?}
     * @private
     */
    AutosizeDirective.prototype._destroyed;
    /** @type {?} */
    AutosizeDirective.prototype.element;
    /**
     * @type {?}
     * @private
     */
    AutosizeDirective.prototype._window;
    /**
     * @type {?}
     * @private
     */
    AutosizeDirective.prototype._zone;
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
}
/**
 * @param {?} func
 * @param {?} wait
 * @param {?=} immediate
 * @return {?}
 */
function Debounce(func, wait, immediate = false) {
    /** @type {?} */
    let timeout;
    return (/**
     * @return {?}
     */
    function () {
        /** @type {?} */
        const context = this;
        /** @type {?} */
        const args = arguments;
        /** @type {?} */
        const later = (/**
         * @return {?}
         */
        function () {
            timeout = null;
            if (!immediate) {
                func.apply(context, args);
            }
        });
        /** @type {?} */
        const callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) {
            func.apply(context, args);
        }
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0b3NpemUuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LWF1dG9zaXplLyIsInNvdXJjZXMiOlsibGliL2F1dG9zaXplLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUNILFVBQVUsRUFDVixZQUFZLEVBQ1osU0FBUyxFQUNULEtBQUssRUFDTCxNQUFNLEVBQTZDLE1BQU0sRUFBRSxZQUFZLEVBQzFFLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBQyxTQUFTLEVBQUMsTUFBTSxzQkFBc0IsQ0FBQzs7TUFFekMsa0JBQWtCLEdBQUcsQ0FBQztBQU01QixNQUFNLE9BQU8saUJBQWlCOzs7Ozs7SUFxQzFCLFlBQ1csT0FBbUIsRUFDbEIsT0FBa0IsRUFDbEIsS0FBYTtRQUZkLFlBQU8sR0FBUCxPQUFPLENBQVk7UUFDbEIsWUFBTyxHQUFQLE9BQU8sQ0FBVztRQUNsQixVQUFLLEdBQUwsS0FBSyxDQUFRO1FBdkJoQixhQUFRLEdBQUcsS0FBSyxDQUFDO1FBQ2pCLGlCQUFZLEdBQUcsS0FBSyxDQUFDO1FBRXBCLFlBQU8sR0FBRyxJQUFJLFlBQVksRUFBVSxDQUFDO1FBRXZDLGFBQVEsR0FBRyxJQUFJLENBQUM7UUFDaEIsWUFBTyxHQUFHLENBQUMsQ0FBQztRQU9aLGVBQVUsR0FBRyxLQUFLLENBQUM7UUFZdkIsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxPQUFPLEtBQUssVUFBVSxFQUFFO1lBQ25ELElBQUksQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO1NBRTlCO2FBQU07WUFDSCxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDO1lBQzdDLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxHQUFHLFFBQVEsQ0FBQztZQUMvQyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztTQUMzQjtJQUNMLENBQUM7Ozs7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QUFDO2FBQzdCO1FBQ0wsQ0FBQyxDQUFBOztjQUNLLE9BQU8sR0FBRyxTQUFTLElBQUksQ0FBQyxPQUFPO1FBQ3JDLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUN0QixPQUFPLEdBQUcsVUFBVSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztRQUNsQyxJQUFJLE9BQU8sRUFBRTtZQUNULElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDO1NBQzdCO0lBQ0wsQ0FBQyxFQUFDO0FBQ04sQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgRWxlbWVudFJlZixcbiAgICBIb3N0TGlzdGVuZXIsXG4gICAgRGlyZWN0aXZlLFxuICAgIElucHV0LFxuICAgIE5nWm9uZSwgT25EZXN0cm95LCBPbkNoYW5nZXMsIEFmdGVyQ29udGVudENoZWNrZWQsIE91dHB1dCwgRXZlbnRFbWl0dGVyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtXaW5kb3dSZWZ9IGZyb20gJy4vd2luZG93LXJlZi5zZXJ2aWNlJztcblxuY29uc3QgTUFYX0xPT0tVUF9SRVRSSUVTID0gMztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbYXV0b3NpemVdJ1xufSlcblxuZXhwb3J0IGNsYXNzIEF1dG9zaXplRGlyZWN0aXZlIGltcGxlbWVudHMgT25EZXN0cm95LCBPbkNoYW5nZXMsIEFmdGVyQ29udGVudENoZWNrZWQge1xuICAgIEBJbnB1dCgpXG4gICAgc2V0IG1pblJvd3ModmFsdWUpIHtcbiAgICAgICAgdGhpcy5fbWluUm93cyA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy50ZXh0QXJlYUVsKSB7XG4gICAgICAgICAgICB0aGlzLnRleHRBcmVhRWwucm93cyA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBASW5wdXQoJ2F1dG9zaXplJylcbiAgICBzZXQgX2F1dG9zaXplKGF1dG9zaXplOiBib29sZWFuIHwgc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuYXV0b3NpemUgPSB0eXBlb2YgYXV0b3NpemUgPT09ICdib29sZWFuJ1xuICAgICAgICAgICAgPyBhdXRvc2l6ZVxuICAgICAgICAgICAgOiB0cnVlO1xuICAgIH07XG4gICAgcHJpdmF0ZSBfbWluUm93czogbnVtYmVyO1xuXG4gICAgQElucHV0KCkgbWF4Um93czogbnVtYmVyO1xuICAgIEBJbnB1dCgpIG9ubHlHcm93ID0gZmFsc2U7XG4gICAgQElucHV0KCkgdXNlSW1wb3J0YW50ID0gZmFsc2U7XG5cbiAgICBAT3V0cHV0KCkgcmVzaXplZCA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuXG4gICAgcHJpdmF0ZSBhdXRvc2l6ZSA9IHRydWU7XG4gICAgcHJpdmF0ZSByZXRyaWVzID0gMDtcbiAgICBwcml2YXRlIHRleHRBcmVhRWw6IGFueTtcblxuICAgIHByaXZhdGUgX29sZENvbnRlbnQ6IHN0cmluZztcbiAgICBwcml2YXRlIF9vbGRXaWR0aDogbnVtYmVyO1xuXG4gICAgcHJpdmF0ZSBfd2luZG93UmVzaXplSGFuZGxlcjtcbiAgICBwcml2YXRlIF9kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAgIEBIb3N0TGlzdGVuZXIoJ2lucHV0JywgWyckZXZlbnQudGFyZ2V0J10pXG4gICAgb25JbnB1dCh0ZXh0QXJlYTogSFRNTFRleHRBcmVhRWxlbWVudCk6IHZvaWQge1xuICAgICAgICB0aGlzLmFkanVzdCgpO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwdWJsaWMgZWxlbWVudDogRWxlbWVudFJlZixcbiAgICAgICAgcHJpdmF0ZSBfd2luZG93OiBXaW5kb3dSZWYsXG4gICAgICAgIHByaXZhdGUgX3pvbmU6IE5nWm9uZVxuICAgICkge1xuICAgICAgICBpZiAodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQudGFnTmFtZSAhPT0gJ1RFWFRBUkVBJykge1xuICAgICAgICAgICAgdGhpcy5fZmluZE5lc3RlZFRleHRBcmVhKCk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGV4dEFyZWFFbCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgdGhpcy50ZXh0QXJlYUVsLnN0eWxlWydvdmVyZmxvdy15J10gPSAnaGlkZGVuJztcbiAgICAgICAgICAgIHRoaXMuX29uVGV4dEFyZWFGb3VuZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLl93aW5kb3dSZXNpemVIYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLl93aW5kb3cubmF0aXZlV2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX3dpbmRvd1Jlc2l6ZUhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nQWZ0ZXJDb250ZW50Q2hlY2tlZCgpIHtcbiAgICAgICAgdGhpcy5hZGp1c3QoKTtcbiAgICB9XG5cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMuYWRqdXN0KHRydWUpO1xuICAgIH1cblxuICAgIF9maW5kTmVzdGVkVGV4dEFyZWEoKSB7XG4gICAgICAgIHRoaXMudGV4dEFyZWFFbCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ1RFWFRBUkVBJyk7XG5cbiAgICAgICAgaWYgKCF0aGlzLnRleHRBcmVhRWwgJiYgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc2hhZG93Um9vdCkge1xuICAgICAgICAgICAgdGhpcy50ZXh0QXJlYUVsID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdURVhUQVJFQScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnRleHRBcmVhRWwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJldHJpZXMgPj0gTUFYX0xPT0tVUF9SRVRSSUVTKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCduZ3gtYXV0b3NpemU6IHRleHRhcmVhIG5vdCBmb3VuZCcpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmV0cmllcysrO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9maW5kTmVzdGVkVGV4dEFyZWEoKTtcbiAgICAgICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50ZXh0QXJlYUVsLnN0eWxlWydvdmVyZmxvdy15J10gPSAnaGlkZGVuJztcbiAgICAgICAgdGhpcy5fb25UZXh0QXJlYUZvdW5kKCk7XG5cbiAgICB9XG5cbiAgICBfb25UZXh0QXJlYUZvdW5kKCkge1xuICAgICAgICB0aGlzLl9hZGRXaW5kb3dSZXNpemVIYW5kbGVyKCk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hZGp1c3QoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2FkZFdpbmRvd1Jlc2l6ZUhhbmRsZXIoKSB7XG4gICAgICAgIHRoaXMuX3dpbmRvd1Jlc2l6ZUhhbmRsZXIgPSBEZWJvdW5jZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl96b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGp1c3QoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCAyMDApO1xuXG4gICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fd2luZG93Lm5hdGl2ZVdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl93aW5kb3dSZXNpemVIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFkanVzdChpbnB1dHNDaGFuZ2VkID0gZmFsc2UpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuYXV0b3NpemUgJiYgIXRoaXMuX2Rlc3Ryb3llZCAmJiB0aGlzLnRleHRBcmVhRWwgJiYgdGhpcy50ZXh0QXJlYUVsLnBhcmVudE5vZGUpIHtcblxuICAgICAgICAgICAgY29uc3QgY3VycmVudFRleHQgPSB0aGlzLnRleHRBcmVhRWwudmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBpbnB1dHNDaGFuZ2VkID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgIGN1cnJlbnRUZXh0ID09PSB0aGlzLl9vbGRDb250ZW50ICYmXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0QXJlYUVsLm9mZnNldFdpZHRoID09PSB0aGlzLl9vbGRXaWR0aFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9vbGRDb250ZW50ID0gY3VycmVudFRleHQ7XG4gICAgICAgICAgICB0aGlzLl9vbGRXaWR0aCA9IHRoaXMudGV4dEFyZWFFbC5vZmZzZXRXaWR0aDtcblxuICAgICAgICAgICAgY29uc3QgY2xvbmUgPSB0aGlzLnRleHRBcmVhRWwuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy50ZXh0QXJlYUVsLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBjbG9uZS5zdHlsZS53aWR0aCA9IHRoaXMudGV4dEFyZWFFbC5vZmZzZXRXaWR0aCArICdweCc7XG4gICAgICAgICAgICBjbG9uZS5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICBjbG9uZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgICBjbG9uZS50ZXh0Q29udGVudCA9IGN1cnJlbnRUZXh0O1xuXG4gICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuXG4gICAgICAgICAgICBjbG9uZS5zdHlsZVsnb3ZlcmZsb3cteSddID0gJ2hpZGRlbic7XG4gICAgICAgICAgICBjbG9uZS5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XG5cbiAgICAgICAgICAgIGxldCBoZWlnaHQgPSBjbG9uZS5zY3JvbGxIZWlnaHQ7XG5cbiAgICAgICAgICAgIC8vIGFkZCBpbnRvIGhlaWdodCB0b3AgYW5kIGJvdHRvbSBib3JkZXJzJyB3aWR0aFxuICAgICAgICAgICAgbGV0IGNvbXB1dGVkU3R5bGUgPSB0aGlzLl93aW5kb3cubmF0aXZlV2luZG93LmdldENvbXB1dGVkU3R5bGUoY2xvbmUsIG51bGwpO1xuICAgICAgICAgICAgaGVpZ2h0ICs9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnYm9yZGVyLXRvcC13aWR0aCcpKTtcbiAgICAgICAgICAgIGhlaWdodCArPSBwYXJzZUludChjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2JvcmRlci1ib3R0b20td2lkdGgnKSk7XG5cbiAgICAgICAgICAgIC8vIGFkZCBpbnRvIGhlaWdodCB0b3AgYW5kIGJvdHRvbSBwYWRkaW5ncyB3aWR0aFxuICAgICAgICAgICAgaGVpZ2h0ICs9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgncGFkZGluZy10b3AnKSk7XG4gICAgICAgICAgICBoZWlnaHQgKz0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdwYWRkaW5nLWJvdHRvbScpKTtcblxuXG4gICAgICAgICAgICBjb25zdCBvbGRIZWlnaHQgPSB0aGlzLnRleHRBcmVhRWwub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgY29uc3Qgd2lsbEdyb3cgPSBoZWlnaHQgPiBvbGRIZWlnaHQ7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9ubHlHcm93ID09PSBmYWxzZSB8fCB3aWxsR3Jvdykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVIZWlnaHQgPSB0aGlzLl9nZXRMaW5lSGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm93c0NvdW50ID0gaGVpZ2h0IC8gbGluZUhlaWdodDtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9taW5Sb3dzICYmIHRoaXMuX21pblJvd3MgPj0gcm93c0NvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuX21pblJvd3MgKiBsaW5lSGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm1heFJvd3MgJiYgdGhpcy5tYXhSb3dzIDw9IHJvd3NDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBuZXZlciBzaHJpbmsgdGhlIHRleHRhcmVhIGlmIG9ubHlHcm93IGlzIHRydWVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF4SGVpZ2h0ID0gdGhpcy5tYXhSb3dzICogbGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5vbmx5R3JvdyA/IE1hdGgubWF4KG1heEhlaWdodCwgb2xkSGVpZ2h0KTogbWF4SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHRBcmVhRWwuc3R5bGVbJ292ZXJmbG93LXknXSA9ICdhdXRvJztcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dEFyZWFFbC5zdHlsZVsnb3ZlcmZsb3cteSddID0gJ2hpZGRlbic7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgaGVpZ2h0U3R5bGUgPSBoZWlnaHQgKyAncHgnO1xuICAgICAgICAgICAgICAgIGNvbnN0IGltcG9ydGFudCA9IHRoaXMudXNlSW1wb3J0YW50ID8gJ2ltcG9ydGFudCcgOiAnJztcblxuICAgICAgICAgICAgICAgIHRoaXMudGV4dEFyZWFFbC5zdHlsZS5zZXRQcm9wZXJ0eSgnaGVpZ2h0JywgaGVpZ2h0U3R5bGUsIGltcG9ydGFudCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZWQuZW1pdChoZWlnaHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZ2V0TGluZUhlaWdodCgpIHtcbiAgICAgICAgbGV0IGxpbmVIZWlnaHQgPSBwYXJzZUludCh0aGlzLnRleHRBcmVhRWwuc3R5bGUubGluZUhlaWdodCwgMTApO1xuICAgICAgICBpZiAoaXNOYU4obGluZUhlaWdodCkgJiYgdGhpcy5fd2luZG93Lm5hdGl2ZVdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKSB7XG4gICAgICAgICAgICBjb25zdCBzdHlsZXMgPSB0aGlzLl93aW5kb3cubmF0aXZlV2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy50ZXh0QXJlYUVsKTtcbiAgICAgICAgICAgIGxpbmVIZWlnaHQgPSBwYXJzZUludChzdHlsZXMubGluZUhlaWdodCwgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTmFOKGxpbmVIZWlnaHQpKSB7XG4gICAgICAgICAgICBjb25zdCBmb250U2l6ZSA9IHRoaXMuX3dpbmRvdy5uYXRpdmVXaW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLnRleHRBcmVhRWwsIG51bGwpLmdldFByb3BlcnR5VmFsdWUoJ2ZvbnQtc2l6ZScpO1xuICAgICAgICAgICAgbGluZUhlaWdodCA9IE1hdGguZmxvb3IocGFyc2VJbnQoZm9udFNpemUucmVwbGFjZSgncHgnLCAnJyksIDEwKSAqIDEuNSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGluZUhlaWdodDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIERlYm91bmNlKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSA9IGZhbHNlKSB7XG4gICAgbGV0IHRpbWVvdXQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIGNvbnN0IGxhdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoIWltbWVkaWF0ZSkge1xuICAgICAgICAgICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgICAgICBpZiAoY2FsbE5vdykge1xuICAgICAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgfVxuICAgIH07XG59XG4iXX0=